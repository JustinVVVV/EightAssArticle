= 数据库教程

数据库是八股文中我最喜欢的东西，特别是一些优化的方案。

``Mysql基础结构``

要想谈数据库优化，首先需要了解数据库的基础结构，现在Mysql大部分都是默认innodb引擎，该引擎底层数据结构是B+树。

在设计数据库底层结构前，我们先明确数据库的需求：

1. 快速读
2. 快速写

如果只需要满足速读的情况，数据一定是顺式存储，这种设计方式就产生了hadoop的一系列产品，他们只要写入后就不推荐修改。

当需要考虑速写时，就一定是链式存储，在链式从存储中，我们有链表和树，如果选用链表，查找性能及其低下，所以选用树。在树结构中有很多优秀的结构，红黑树、二叉树、b树、b+树、hash。我在下文中将会对这些类型进行以一分析。

我们假设有1000w数据，对各种结构的数据进行对比


|===
| |查询 |插入 |删除

|红黑树
|24
|26-27
|26-27

|b树
|3
|4-5
|4-5

|b+树
|3
|4-5
|4-5

|hash
|1
|1
|1
|===

可以看出红黑树的性能大概在b树8倍左右，但是hash性能却十分优异，那么数据库数据结构为什么不选择hash呢？

这就是数据库需求以外的另一个需求，范围查找。hash表在做范围查找的时候性能很差，而b+树由于数据都在叶子节点上，可以通过链表轻松的定位位置，每次走到下一个位置需要1次操作，所以性能优于数据同时分布在叶子和节点上，每次走到下一个位置需要1-最深深度步数的b树。

除此以外，hash表由于碰撞的问题，还需要极大的空间，否则性能就会和链表相似。

***
= 索引

了解数据库数据结构以后，我们就可以畅快的写sql，但是sql的性能常常是程序员们互相攀比的数据，你多耗时1ms就好像落后于人一样，下面我会写写我对sql优化的理解，尤其是索引机制。

众所周知，sql是一种语言规范，mysql在执行sql的时候，需要先将sql语言转成其能理解的语法树，然后优化执行逻辑，最后执行。那么这个语法树转换和执行逻辑优化就很有搞头，里面塞满了各种各样的语法糖和神乎其神的优化思路。我也只是通过一些实验发现了一些小技巧。

首先是执行顺序，sql的编写是有固定的顺序的。通常为：

`select column,count(\*) from table_a join table_b on table_a.id=table_b.id where 1=1 group by column having(count(*))>1 order by column`

这样一条sql在执行时首先将两张表通过on的condition相连，得到了一张新的结果表result，在1=1的条件判断下，过滤出了结果表2，在执行group by 聚合函数，对符合条件的结果集进行计算。此时，机灵的sql编写者觉得还需要在做一次过滤，但是第一次过滤的机会已经在where中使用过了，怎么办？sql规范制定者想到了可以使用having来代替where，所以having 条件对结果集又进行了一次过滤，最后是将结果集按照指定顺序排序。

由这样一条sql执行的逻辑我们可以看出sql规范指定者煞费苦心，他们希望sql编写人员能按照规矩从左往右一个一个写，那么索引的使用也一定是这样的逻辑。

在给sql优化逻辑时，首先会将符合where条件的索引挑选出来，where里面有多个条件怎么办，肯定会优先全匹配。因此优雅的索引一定是能完全匹配where语句中的所有情况的。

如果不能匹配全部条件怎么办？那就只好从左往右一个一个索引查询，所以在写where条件时，最好把过滤内容最多的语句写在最前面。

此外在表join时，最好是小表在前，大表在后。这个优化原则我并没有找到证据，但是根据我的理解，如果小表在前，sql优先执行小表的查询逻辑，内存中只需要存放小表数据，性能应该是会优于大表在前的。

***
上面写了一些我在使用索引时的心得。下面我会写一些关于我对索引的思考。

我们都知道计算机的存储大部分情况是段页式的，首先是计算机在磁盘的基础上模拟出页这个概念，保证上层使用人员无需直接接触下层磁盘磁道等复杂的概念，每个页都是固定大小。在此基础上，更上层的使用人员不希望自己的使用空间被其他人所占用，于是就诞生了段表，这样保证每一个页都被自己独享，并且能通过从段表中查询到页的位置，最终以链接的形式快速的查找到数据在磁盘中的位置。

看到段页式的设计，是不是一下子让人想到了上面的B+树。其实索引也是如此。在不破坏原有数据结构、内容的同时，在外部构建了页、段等链接内容。简单来说，索引是在插入表数据时，存储在了另一张表中。所以我们在查询数据时，其实是先从索引表中查询位置，然后通过链接找到对应数据。这个过程很像从段表中查询页表的位置。这就是为什么索引在sql中如此重要，它能够将数据查询从全量变为部分。

索引如此重要，但是索引只支持=运算，其他所有范围运算都会直接破坏索引。我们可以做一个比较，范围结果需要遍历全部数据才能得到所有匹配值，如果走索引的话，这个遍历和不走索引其实是一样的。

在此基础上，我们再思考一个小问题，数据离散程度对索引效果会有影响吗？

答案是肯定的，并且数据越离散，索引效果越好。这是为什么呢？索引的存在是为了能够直接找到数据所在的位置，将数据从存储中搬运出来，如果数据离散程度很小，则并不能减少查询位置所在的次数，因为只需要找到一个位置，就可能找到了剩下全部需要的数据，比从索引查找慢不了多少。但如果数据很离散，每次查找都可以精准的找到一个位置，索引就能帮助过滤掉很多无关数据，所以此时索引的效率是立竿见影的。

***
= 内存表

这是一种很有意思的操作，在建表时，就将表设计为内存存储，但是我没有尝试过。只是看到了这样一种手段。

***
= 分库分表

分库分表是另一种能大幅度提高查询性能的优化方案，但此方案的核心改造不在数据库，而在应用端。这就带来了很多的问题。





